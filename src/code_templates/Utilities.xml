<codeTemplateLibrary version="3.5.1">
  <id>6975d386-da5e-4267-aa01-5d181743a931</id>
  <name>Utilities</name>
  <revision>26</revision>
  <lastModified>
    <time>1528296902784</time>
    <timezone>America/Chicago</timezone>
  </lastModified>
  <description>This library was added upon migration to version 3.3.0. It includes all pre-existing
code templates, and is set to be included on all pre-existing and new channels.

You should create your own new libraries and assign code templates to them as you
see fit. You should also link libraries to specific channels, so that you&apos;re not
necessarily including all code templates on all channels all the time.</description>
  <includeNewChannels>true</includeNewChannels>
  <enabledChannelIds>
    <string>38e80069-5a80-4483-9a22-02c928973719</string>
    <string>6a2a6c33-33da-4783-b823-bd95bf387981</string>
    <string>5beae4c2-e7f8-4ae3-9fca-703dea9233a2</string>
    <string>3f5ab859-f917-484f-b841-7c9e39174b8e</string>
    <string>82ac96ff-a32d-42b2-81a4-80ebda4783db</string>
    <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
    <string>24504c80-a7ef-496d-bca0-c25ce27f4d19</string>
    <string>06d19851-fbd2-446b-be8f-12965d966d2a</string>
    <string>280d822c-1479-4fb6-9e2a-b7267e540c63</string>
    <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
    <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
    <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
    <string>1ae4e7ac-e62f-468c-aa2a-99cbd6139838</string>
    <string>2f6cd9fb-90e2-4121-b05a-cad72d278cc3</string>
    <string>360b408e-86e7-43da-875a-11dd5f07db7e</string>
    <string>0edf321a-b712-47e2-972a-03f2c4c8f0ac</string>
    <string>05075884-fedf-4b8c-96b1-eecaaaf97842</string>
    <string>1892f241-d643-4abb-b0af-b20b87e0cf12</string>
    <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
    <string>15708463-af53-428c-88f5-16351dd49b2e</string>
    <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
    <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
    <string>03bc65a0-25b4-48f5-8455-7e58e71b1446</string>
    <string>0638775c-6c87-4a71-b4b3-7ae52be05c1b</string>
    <string>2dbdcefd-11b5-42c8-a365-05038df92fef</string>
    <string>082c9258-e026-460b-a7bb-e67391ef65f9</string>
    <string>06bd4ce9-2338-4c78-86fb-2e04ff9f9e08</string>
    <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
    <string>e882ff76-1127-4e35-838c-93cbc2655ef9</string>
    <string>27139815-1d29-4f32-ad00-fc266f2448cd</string>
    <string>197d7939-edb9-4dc7-af2d-ab91ae9023ad</string>
    <string>368263c0-b071-4c57-afeb-61dc82a898be</string>
    <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
  </enabledChannelIds>
  <disabledChannelIds/>
  <codeTemplates>
    <codeTemplate version="3.5.1">
      <id>3bff8e77-8269-463a-aa9d-b3539c885d70</id>
      <name>calcSizeBase64EncodedMsg</name>
      <revision>1</revision>
      <lastModified>
        <time>1518492121304</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function calcSizeBase64EncodedMsg(size) {

	var code_size=    ((size*4)/3)
	var padding_size= (size % 3) ? (3- (size % 3)) : 0;
	var crlfs_size=   2 + (2 * (code_size + padding_size) / 72);
	var total_size=   code_size + padding_size + crlfs_size;

	return total_size;
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>b9651842-7ccb-4761-aedf-a9a1461dd5f7</id>
      <name>Convert HL7 Date Format to ISO</name>
      <revision>1</revision>
      <lastModified>
        <time>1525526013518</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Converts standard HL7 v2.x date format to human-readable ISO date format
*/

/*
	Author: IntegrateIT.us LLC
	toISODate: Returns an ISO-formatted date string with specified timezone offset

	Arguments
	---------
		Required
		--------
			hl7DateString:		An HL7-formatted date string (ex: &quot;yyyyMMddHHmmss&quot;

		Optional
		--------
			timezome:			A timezone identifier string corresponding to one of the java.util.TimeZone values (ex: &quot;US/Central&quot;)
*/

function toISODate( hl7DateString, timezone ) {
	var isoDate;
	var dateString;
	var hl7Formatter;
	var isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;);

	if (timezone) {
		isoFormatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(timezone));
	}
	
	if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString.substring(0,13)) &amp;&amp; hl7DateString.length &gt; 14 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssZ&quot;);
	}
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 14 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
	} 
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 12 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmm&quot;);
	} 
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 8 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;);
	} 
	else dateString = hl7DateString;
	
	try {
		if (hl7Formatter) {
			isoDate = hl7Formatter.parse(hl7DateString);
			isoDate = isoFormatter.format(isoDate);
			dateString = new String(isoDate);
		}
	} catch (err) {
		dateString = hl7DateString;
	} finally {
		return dateString;
	}
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>95e528b7-1e7f-490e-86da-7c14b23ee4f3</id>
      <name>Convert ISO Date Format to HL7</name>
      <revision>1</revision>
      <lastModified>
        <time>1525526031270</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Converts ISO date format to HL7 v2 format
*/

/*
	Author: IntegrateIT.us LLC
	toHL7Date: Returns an HL7-formatted date string with specified timezone offset

	Arguments
	---------
		Required
		--------
			isoDateString:		An ISO-formatted date string (ex: &quot;yyyy-MM-ddTHH:mm:ssZ&quot;

		Optional
		--------
			timezome:			A timezone identifier string corresponding to one of the java.util.TimeZone values (ex: &quot;US/Central&quot;)
*/

function toHL7Date( isoDateString, timezone ) 
{
	var hl7Date;
	var dateString;
	var isoFormatter;
	var hl7Formatter;

	// ISO Date Format: yyyy-MM-dd&apos;T&apos;HH:mm:ss&apos;Z&apos;
	if ( isoDateString != null &amp;&amp; isoDateString.length &lt;= 25 &amp;&amp; isoDateString.length &gt;= 22) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssZ&quot;);
		if (timezone) {
			hl7Formatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(timezone));
		}
	}
	// ISO Date Format: yyyy-MM-dd HH:mm:ss
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 19 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
	}
	// ISO Date Format: yyyy-MM-dd HH:mm
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 16 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmm&quot;);	
	} 
	// ISO Date Format: yyyy-MM-dd
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 10 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;);	
	}
	// None of the above, return original date string.
	else dateString = isoDateString;

	try {
		if (isoFormatter) {
			hl7Date = isoFormatter.parse(isoDateString);
			hl7Date = hl7Formatter.format(hl7Date);
			dateString = new String(hl7Date);
		}
	} catch (err) {
		dateString = isoDateString;
	} finally {
		return dateString;
	}
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>1e4358bb-21bc-4823-bc55-e41caff65bea</id>
      <name>convertDate</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831341</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	convertDate(date, outpattern)
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
var patterns = [
	&apos;yyyy-MM-dd HH:mm:ss:SSS&apos;,
	&apos;yyyy-MM-dd HH:mm:ss.SSS&apos;,
	&apos;yyyy-MM-dd HH:mm:ss&apos;,
	&apos;yyyy-MM-dd HH:mm&apos;,
	&apos;EEE MMM dd HH:mm:ss:SSS zzz yyyy&apos;,
	&apos;EEE MMM dd HH:mm:ss.SSS zzz yyyy&apos;,
	&apos;EEE MMM dd HH:mm:ss zzz yyyy&apos;,
	&apos;EEE MMM dd zzz yyyy&apos;,
	&apos;dd-MMM-yyyy HH:mm:ss:SSS&apos;,
	&apos;dd-MMM-yyyy HH:mm:ss.SSS&apos;,
	&apos;dd-MMM-yyyy HH:mm:ss&apos;,
	&apos;yyyy-MM-dd&apos;,
	&apos;yyyy MM dd&apos;,
	&apos;yyyy.MM.dd&apos;,
	&apos;MM-dd-yyyy&apos;,
	&apos;MM dd yyyy&apos;,
	&apos;MM.dd.yyyy&apos;,
	&apos;HH:mm:ss:SSS&apos;,
	&apos;HH:mm:ss.SSS&apos;,
	&apos;HH:mm:ss&apos;,
	&apos;yyyyMMddHHmmssSSS&apos;,
	&apos;yyyyMMddHHmmss&apos;,
	&apos;yyyyMMddHHmm&apos;,
	&apos;hh:mm aa&apos;];

var formatters = [];
for each (pattern in patterns) {
	formatters.push(org.joda.time.format.DateTimeFormat.forPattern(pattern));
}

function convertDate(date, outpattern) {
	var instant = 0;
	if (typeof date == &apos;number&apos; || date instanceof java.lang.Number)
		instant = new Number(date);
	else if (date instanceof Date || date instanceof java.util.Date)
		instant = date.getTime();
	else if (date instanceof org.joda.time.ReadableInstant)
		instant = date.getMillis();
	else {
		for each (formatter in formatters) {
			try {
				instant = formatter.parseMillis(new String(date));
				break;
			} catch(e) {}
		}
	}

	return org.joda.time.format.DateTimeFormat.forPattern(outpattern).print(instant);
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>c741ad20-3baa-4880-a355-79761040ed4a</id>
      <name>createSegmentBefore</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831364</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	createSegmentBefore
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function createSegmentBefore(insertSegmentName, beforeThisSegment) {
	var msgObj = beforeThisSegment;
	while (msgObj.parent() != undefined) {
		msgObj = msgObj.parent();
	}
	msgObj.insertChildBefore(beforeThisSegment[0], new XML(&apos;&lt;&apos; + insertSegmentName + &apos;&gt;&lt;/&apos; + insertSegmentName + &apos;&gt;&apos;));
	return msgObj.child(beforeThisSegment[0].childIndex() - 1);
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>a5e92dbd-69ee-408e-90bf-7ab5f0539f2f</id>
      <name>currentDate_yyyyMMddhhmmss</name>
      <revision>8</revision>
      <lastModified>
        <time>1517525072758</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/** currentDate_yyyyMMddhhmmss

	@return {String} return currentDate in yyyyMMddhhmmss string format

	// Modified: To include addition checks on the length of each datepart 
*/
function currentDate_yyyyMMddhhmmss() {

	var debug= 0;
	
	var today = new Date();
	var day = today.getDate();
	var month = today.getMonth()+1; //January is 0!
	var year = today.getFullYear();
	var hour = today.getHours();	// 0-23
	var minute = today.getMinutes();	// 0-59
	var second = today.getSeconds();  // 0-59

	if(day.toString().length&lt;2) { day = &apos;0&apos;+day } 
	if(month.toString().length&lt;2) { month = &apos;0&apos;+month }
	if(hour.toString().length&lt;2) { hour = &apos;0&apos;+hour }
	if(minute.toString().length&lt;2) { minute = &apos;0&apos;+minute }
	if(second.toString().length&lt;2) { second = &apos;0&apos;+second }

	var newDate= year+month+day+hour+minute+second;
	if(debug&gt;0) { logger.error(&quot;currentDate_yyyyMMddhhmmss() returns: &quot;+newDate); }
	return newDate;

}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>d0d5a392-cea8-40e7-9c12-dd8547c8b51e</id>
      <name>daysBetween</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831376</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	daysBetween(begin, end, pattern)
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function daysBetween(begin,end,pattern) {
	importPackage(org.joda.time);
	importPackage(org.joda.time.format);
	String.prototype.toDate = function(pattern) {return DateTimeFormat.forPattern(pattern || &apos;yyyyMMddHHmmss&apos;).parseDateTime(this);};
	return Days.daysBetween(convert(begin),convert(end)).getDays();
	function convert(object) {
		if (&apos;string&apos; === typeof object || object instanceof String)
			return (object + &apos;19700101000000&apos;.substr(object.length)).toDate(pattern);
		else if (object instanceof Date || object instanceof java.util.Date)
			return new DateTime(object.getTime());
		else 
			return new DateTime(object);
	}
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>8ee9e3a6-5cf4-4b68-bdcc-7b5013860cb8</id>
      <name>executeOperation</name>
      <revision>3</revision>
      <lastModified>
        <time>1527795423647</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Executes executeOperation(operation, expression, parameters) - references getDBConnection

	@param 
	{string operation} - executeUpdate (INSERT|UPDATE), executeCachedQuery (SELECT) operations 
	{string expression} - expression of INSERT, UPDATE, DELETE or SELECT statements
	{string parameters} - parameterized parameter values accompanying the expression statement
	@return {DatabaseConnection} The database connection dbConn object.
	
	Example
	executeOperation(&apos;executeUpdate&apos;, expression, parameters);
	WHERE
	var expression = &quot;INSERT INTO hl7_test_sample (patient_last_name, patient_first_name, patient_middle_initial) VALUES (?, ?, ?);&quot;
	var result = dbConn.executeUpdate(expression, params);
*/

function executeOperation(operation, expression, parameters) {

	var dbConn = getDBConnection(true);
	var attempts = 0;
	var maxAttempts = NumberUtils.toInt($(&apos;dbRetries&apos;) + &apos;&apos;, 0) + 1;

	while (attempts &lt; maxAttempts) {
		attempts++;

		try {
			if (parameters) {
				for (var i in parameters) {
					var param = parameters[i];
					if (param instanceof Number) {
						parameters[i] = new java.lang.Integer(param);
					}
				}
				
				return dbConn[operation](expression, java.util.Arrays.asList(parameters));
			} else {
				return dbConn[operation](expression);
			}
		} catch (e) {
			logger.info(&apos;Error executing statement, checking if valid...&apos;);

			try {
				dbConn.executeCachedQuery(&apos;SELECT 1&apos;);
			} catch (e2) {
				logger.info(&apos;Connection invalid, recreating...&apos;);

				try {
					dbConn = getDBConnection(true);
				} catch (e3) {}
			}

			if (attempts &gt;= maxAttempts) {
				var errorMessage = &apos;Unable to execute statement.\n&apos;;
				errorMessage += &apos;Expression: &apos; + expression + &apos;\n&apos;;
				if (parameters) {
					errorMessage += &apos;Parameters: &apos; + java.util.Arrays.asList(parameters).toString();
				}
				logger.error(errorMessage, e.javaException);
				throw e;
			}

			java.lang.Thread.sleep(1000);
		}
	}
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>7a091e64-db98-4f28-9990-59e8a7a67b4a</id>
      <name>getByteCount</name>
      <revision>1</revision>
      <lastModified>
        <time>1518489356999</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/** getByteCount
	
	- Desc: provide string and determine the byteSize of the string

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function getByteCount( s )
{
  var count = 0, stringLength = s.length, i;
  s = String( s || &quot;&quot; );
  for( i = 0 ; i &lt; stringLength ; i++ )
  {
    var partCount = encodeURI( s[i] ).split(&quot;%&quot;).length;
    count += partCount==1?1:partCount-1;
  }
  return count;
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>6c50e580-bb31-4b00-9b20-d47caa381eb9</id>
      <name>getByteLen</name>
      <revision>1</revision>
      <lastModified>
        <time>1518489683097</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/** getByteLen 

	Using UTF-8 character determine number of Bytes in UTF-8 string
 	Count bytes in a string&apos;s UTF-8 representation.
 
 	@param   string
 	@return  int
*/

function getByteLen(normal_val) {
    // Force string type
    normal_val = String(normal_val);

    var byteLen = 0;
    for (var i = 0; i &lt; normal_val.length; i++) {
        var c = normal_val.charCodeAt(i);
        byteLen += c &lt; (1 &lt;&lt;  7) ? 1 :
                   c &lt; (1 &lt;&lt; 11) ? 2 :
                   c &lt; (1 &lt;&lt; 16) ? 3 :
                   c &lt; (1 &lt;&lt; 21) ? 4 :
                   c &lt; (1 &lt;&lt; 26) ? 5 :
                   c &lt; (1 &lt;&lt; 31) ? 6 : Number.NaN;
    }
    return byteLen;
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>1c06363e-daf9-4a6c-b35c-f4208db4b701</id>
      <name>getDBConnection</name>
      <revision>2</revision>
      <lastModified>
        <time>1527381258822</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	getDBConnection - Retrieves the database connection from the global channel map, creating a new one if necessary.

	@param {Boolean} recreate - If true, the connection will always be closed and created anew.
	@return {DatabaseConnection} The database connection object.
*/
function getDBConnection(recreate) {
	var dbConn = $gc(&apos;dbConn&apos;);

	if (!dbConn || recreate) {
		if (dbConn) {
			try {
				dbConn.close();
			} catch (e) {}
		}
		dbConn = DatabaseConnectionFactory.createDatabaseConnection($(&apos;mysqlDriverString&apos;), $(&apos;mysqlUrlLocalHostString&apos;), $(&apos;mysqlUser&apos;), $(&apos;mysqlPassword&apos;));
		$gc(&apos;dbConn&apos;, dbConn);
	}

	return dbConn;
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>6bc382b4-149d-4c27-a333-a76af0a63fb9</id>
      <name>getMySqlConn</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831350</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>CHANNEL_BATCH</contextType>
          <contextType>CHANNEL_PREPROCESSOR</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>CHANNEL_UNDEPLOY</contextType>
          <contextType>CHANNEL_DEPLOY</contextType>
          <contextType>GLOBAL_POSTPROCESSOR</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>CHANNEL_POSTPROCESSOR</contextType>
          <contextType>CHANNEL_ATTACHMENT</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	getMySqlConn
*/
// code template
function getMySqlConn() { 
    return DatabaseConnectionFactory.createDatabaseConnection($(&apos;mysqlDriverString&apos;) , $(&apos;mysqlUrlLocalHostString&apos;) , $(&apos;mysqlUser&apos;) , $(&apos;mysqlPassword&apos;));
} // end function</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>4cb42e06-7c9a-4fd2-bcb5-b9f4053a9c19</id>
      <name>getSegmentsAfter</name>
      <revision>2</revision>
      <lastModified>
        <time>1525526636419</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Returns an array of segments with the specified name that come after a given segment in the message.
*/
/*
	Author: Nick Rupley
	Date Modified: 2/13/2013
	getSegmentsAfter: Returns an array of segments with the specified name that come after a given segment in the message.

	Arguments
	---------
		Required
		--------
			root:			The root HL7Message node of the message, or the parent of the segment node.
			startSeg:		The segment AFTER which to start collecting segments.
			segName:		The name (String or RegExp) of the segments you want to collect.

		Optional
		--------
			consecutiveInd:	If true, indicates that the segments are expected to come directly after startSeg. 
							If false, segments are collected until another segment with the same name as startSeg is encountered.
							Defaults to false.
			stopSegNames:	An array of segment names that, when encountered, stop the collection of segments.
*/

function getSegmentsAfter(root, startSeg, segName, consecutiveInd, stopSegNames) {
	function test(str) {
		return segName instanceof RegExp ? segName.test(str) : segName === str;
	}

	// The index to start collection is the next one up from the starting segment
	var index = startSeg.childIndex()+1;
	// The return array
	var out = [];
	// Boolean placeholder to stop iteration
	var done = false;
	// Object that will contain all of the stopSegNames strings, bound to a truthy value (1)
	var stopNames = {};
	// Indicates whether we have any stop segments
	var stopNamesInd = false;
	// If stopSegNames is defined
	if (stopSegNames !== undefined &amp;&amp; stopSegNames !== null) {
		// Set our indicator to true
		stopNamesInd = true;
		// Add each string in the array to our object
		for each (name in stopSegNames)
			stopNames[name] = 1;
	}

	// Iterate through each child in the root, starting at the segment after startSeg, and
	// ending at the final segment, or when the done flag is set to true.
	while (index &lt; root.children().length() &amp;&amp; !done) {
		// If a stop segment is encountered, stop iteration
		if (stopNamesInd &amp;&amp; root.children()[index].name().toString() in stopNames)
			done = true;
		// If a segment with the same name as startSeg is encountered, stop iteration
		else if (root.children()[index].name().toString() == startSeg.name().toString() &amp;&amp; !consecutiveInd)
			done = true;
		// If we&apos;re only collecting consecutive segments and we encounter a segment with a name other than segName, stop iteration
		else if (!test(root.children()[index].name().toString()) &amp;&amp; consecutiveInd)
			done = true;
		// If all previous tests passed, and the current segment has a name of segName, then add it to our array
		else if (test(root.children()[index].name().toString()))
			out.push(root.children()[index]);
		// Increment our index counter
		index++;
	}

	// Return the output array
	return out;
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>9fd1f0f6-a856-483d-a8b5-ec707df483d4</id>
      <name>getXSLTransformation</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831355</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	getXSLTransformation(source, xsltFilePath)
*/
function getXSLTransformation(source, xsltFilePath) { 
	var reader = new Packages.java.io.StringReader(source.toString()); 
	var result = new Packages.java.io.StringWriter(); 
	var xsltFile = new Packages.java.io.File(xsltFilePath); 
	var xsltSource = new Packages.javax.xml.transform.stream.StreamSource(xsltFile); 
	try { 
		var transFact = new Packages.javax.xml.transform.TransformerFactory.newInstance(); 
		var transXSLT = transFact.newTemplates(xsltSource); 
		var trans = transXSLT.newTransformer(); 
		trans.transform(new Packages.javax.xml.transform.stream.StreamSource(reader), new Packages.javax.xml.transform.stream.StreamResult(result)); 
	} catch(err) {
		logger.error(&apos;getXSLTransformation exception: &apos; + err); 
	} // end try
	return result.toString().replace(&apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&apos;,&apos;&apos;); 
} // end function</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>4bf0193f-6728-4c89-ae26-63d8c913ba67</id>
      <name>insert_into_table</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831346</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>CHANNEL_BATCH</contextType>
          <contextType>CHANNEL_PREPROCESSOR</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>CHANNEL_UNDEPLOY</contextType>
          <contextType>CHANNEL_DEPLOY</contextType>
          <contextType>GLOBAL_POSTPROCESSOR</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>CHANNEL_POSTPROCESSOR</contextType>
          <contextType>CHANNEL_ATTACHMENT</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	insert_into_table(tableName, columnArray, debug, select_log)
*/
function insert_into_table(tableName, columnArray, debug, select_log) {
	// targetColumnArray= {&apos;exam_code&apos;,&apos;exam_source&apos;};
	// columnArray= {&apos;exam_code:ARTMJRT&apos;,&apos;exam_description:ARTHROGRAM TEMPOROMANDIBULAR JOINT RIGHT&apos;,&apos;exam_source:RISIC&apos;,&apos;source_description:FINAL RISIC EXAM IC CODES POST 8-11-15&apos;};
	var insert_log= select_log
	if(typeof(debug)== &apos;undefined&apos;) 		var debug= 0;
	if(typeof(insert_log)== &apos;undefined&apos;)	var insert_log= &apos;&apos;;
	var i= 1;
	// define insert statement
	// 		if(column.split(&quot;:&quot;)[0].toString().indexOf(&apos;date&apos;)&lt;0)
	var insert= &quot;INSERT INTO &quot; + tableName + &quot; (&quot;;
	for each(column in columnArray) {
		if(i&lt;columnArray.length)
			insert+= column.split(&quot;:&quot;)[0]+&quot;,&quot;;
		else
			insert+= column.split(&quot;:&quot;)[0] + &quot;)&quot;;
		i++;
	} // end for each
	insert+= &quot; VALUES (&quot;;
	var i= 1;
	for each(colValue in columnArray) {
		if(colValue.split(&quot;:&quot;)[0].toString().indexOf(&apos;date&apos;)&lt;0)
			if(i&lt;columnArray.length)
				insert+= &quot;&apos;&quot;+colValue.split(&quot;:&quot;)[1]+&quot;&apos;,&quot;;
			else
				insert+= &quot;&apos;&quot;+colValue.split(&quot;:&quot;)[1] + &quot;&apos;);&quot;;
		else
			if(i&gt;=columnArray.length)
				insert+= &quot;NOW());&quot;;
			else
				insert+= &quot;NOW(),&quot;;
		i++;
	} // end for each
	if(debug&gt;=1) channelMap.put(&apos;insert_&apos;+tableName,insert);
	try {
		var dbConn= getMySqlConn();
		// dbConn = DatabaseConnectionFactory.createDatabaseConnection($(&apos;mysqlDriverString&apos;),$(&apos;mysqlUrlLocalHostString&apos;),$(&apos;mysqlUser&apos;),$(&apos;mysqlPassword&apos;));
		var result = dbConn.executeUpdate(insert);
		if (result != null) {
			insert_log+= &apos; Attempt to insert record for exam_source. &apos;;
			var i= 1;
			for each(column in columnArray) {
				var columnName=   column.split(&quot;:&quot;)[0].toString();
				var columnValue=  column.split(&quot;:&quot;)[1].toString();
				if(i&lt;columnArray.length) 
					insert_log+= columnName+&apos;= &apos;+columnValue+&apos; AND &apos;;
				else
					insert_log+= columnName+&apos;= &apos;+columnValue+&apos;.&apos;;
				i++;
			} // end for each
			channelMap.put(&apos;action&apos;,&apos;INSERT&apos;);
			if(debug&gt;=1) channelMap.put(&apos;insert_log_&apos;+tableName,insert_log);
			if(debug&gt;=2) logger.error(&quot;[Insert &quot;+tableName+&quot;] &quot;+insert_log);
			channelMap.put(&apos;select_log&apos;,insert_log+=&apos; [Inserted record]&apos;);
		} else {
			channelMap.put(&apos;action&apos;,&apos;FAILED INSERT&apos;);
			channelMap.put(&apos;select_log&apos;,insert_log+=&apos; [Failed to insert record]&apos;);
		} // end if	
		dbConn.close();
	} catch(err){
		logger.error(err);
		channelMap.put(&apos;action&apos;,&apos;ERROR&apos;);
	} finally {	
		if (dbConn) { 
			dbConn.close();
		}
	} // end try
} // end function</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>e250b526-5bcc-4973-ae7b-7efa49605a2a</id>
      <name>insertSegmentAfter</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831380</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	insertSegmentAfter
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function insertSegmentAfter(insertSegment, afterThisSegment) {
	var msgObj = afterThisSegment;
	while (msgObj.parent() != undefined) {
		msgObj = msgObj.parent();
	}
	msgObj.insertChildAfter(afterThisSegment[0], insertSegment);
	return msgObj.child(afterThisSegment[0].childIndex() + 1);
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>1525b940-91eb-4afc-871c-b0d5ad6ac337</id>
      <name>insertSegmentBefore</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831336</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	insertSegmentBefore
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function insertSegmentBefore(insertSegment, beforeThisSegment) {
	var msgObj = beforeThisSegment;
	while (msgObj.parent() != undefined) {
		msgObj = msgObj.parent();
	}
	msgObj.insertChildBefore(beforeThisSegment[0], insertSegment);
	return msgObj.child(beforeThisSegment[0].childIndex() - 1);
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>0a6a03d5-9525-4090-ad10-d17c3ab742e9</id>
      <name>removeDupAttributesFromXML</name>
      <revision>1</revision>
      <lastModified>
        <time>1502489831325</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>CHANNEL_BATCH</contextType>
          <contextType>CHANNEL_PREPROCESSOR</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>CHANNEL_UNDEPLOY</contextType>
          <contextType>CHANNEL_DEPLOY</contextType>
          <contextType>GLOBAL_POSTPROCESSOR</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>CHANNEL_POSTPROCESSOR</contextType>
          <contextType>CHANNEL_ATTACHMENT</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	removeDuplicateAttributesFromXML
*/
// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function removeDuplicateAttributesFromXML(section) {
	// desc: Remove Duplicate Telecom Attributes from XML
	var debug= 1 // 0= OFF, 1= channelMap, 2= logger.error
	var tDescription= &apos;[Pre-Processor][Remove Duplicate Telecom Attributes from XML]&apos;;
	var arrObservation= new Array();
	var i= 0
	// use section instead of message but convert section to message variable
	var message= section;
	if(debug&gt;=2) logger.error(&apos;original msg Section= &apos;+message);

	if(message.toString().indexOf(&apos;author&apos;)&gt;-1) {
		author= message;
		if(debug&gt;=2) logger.error(&apos;message= &apos;+message);
		if(author.toString().indexOf(&apos;assignedAuthor&apos;)&gt;-1) {
			var beginAssignedAuthor= author.toString().indexOf(&apos;&lt;assignedAuthor&gt;&apos;);
			var endAssignedAuthor= author.toString().indexOf(&apos;&lt;/assignedAuthor&gt;&apos;);
			var assignedAuthor= author.toString().substring(beginAssignedAuthor, endAssignedAuthor);
			if(debug&gt;=2) logger.error(&apos;assignedAuthor= &apos;+assignedAuthor);
			if(assignedAuthor.toString().indexOf(&apos;representedOrganization&apos;)&gt;-1) {
				var beginRepresentedOrganization= assignedAuthor.toString().indexOf(&apos;&lt;representedOrganization&gt;&apos;);
				var endRepresentedOrganization= assignedAuthor.toString().indexOf(&apos;&lt;/representedOrganization&gt;&apos;);
				var representedOrganization= assignedAuthor.toString().substring(beginRepresentedOrganization, endRepresentedOrganization);
				if(debug&gt;=2) logger.error(&apos;begin= &apos;+beginRepresentedOrganization+&apos; end= &apos;+endRepresentedOrganization+&apos; representedOrganization= &apos;+representedOrganization);
				if(representedOrganization.toString().indexOf(&apos;telecom&apos;)&gt;-1) {
					var beginTelecom= representedOrganization.toString().indexOf(&apos;&lt;telecom&apos;);
					var endTelecom= representedOrganization.toString().indexOf(&apos;&lt;addr&apos;);
					var telecom= representedOrganization.toString().substring(beginTelecom, endTelecom);
					if(debug&gt;=2) logger.error(&apos;begin= &apos;+beginTelecom+&apos; end= &apos;+endTelecom+&apos; telecom= &apos;+telecom);
					var objObservation= new Object();
					objObservation.id= i;
					beginTelecomValue= 		telecom.toString().indexOf(&apos;value=&apos;);
					endTelecomValue=   		telecom.toString().indexOf(&apos; use=&apos;);
					objObservation.value=	telecom.toString().substring(beginTelecomValue+6, endTelecomValue).replace(/&quot;/g,&apos;&apos;)
					beginTelecomUse=   		telecom.toString().indexOf(&apos;use=&apos;);
					objObservation.use= 	telecom.toString().substring(beginTelecomUse+4, beginTelecomUse+7).replace(/&quot;/g,&apos;&apos;);
					arrObservation.push(objObservation);
					var newTelecom= &apos;&lt;telecom value=&quot;&apos;+objObservation.value+&apos;&quot; use=&quot;&apos;+objObservation.use+&apos;&quot;/&gt;&apos;;
					var newRepresentedOrganization= representedOrganization.replace(telecom, newTelecom);
					if(debug&gt;=1) channelMap.put(tDescription,&apos;old= &apos;+telecom+&apos; new= &apos;+newTelecom);
					if(debug&gt;=2) logger.error(tDescription+&apos; old= &apos;+telecom+&apos; new= &apos;+newTelecom);
				} // end if
			} // end if 
			var newAssignedAuthor= assignedAuthor.replace(representedOrganization,newRepresentedOrganization);
		} // end if 
		var newAuthor=		author.replace(assignedAuthor,newAssignedAuthor);
		var newXmlMsg=		message.replace(author,newAuthor);
	} else if(message.toString().indexOf(&apos;custodian&apos;)&gt;-1) {
		custodian= message;
		if(debug&gt;=2) logger.error(&apos;message= &apos;+message);
		if(custodian.toString().indexOf(&apos;assignedCustodian&apos;)&gt;-1) {
			var beginAssignedCustodian= custodian.toString().indexOf(&apos;&lt;assignedCustodian&gt;&apos;);
			var endAssignedCustodian= 	custodian.toString().indexOf(&apos;&lt;/assignedCustodian&gt;&apos;);
			var assignedCustodian= 		custodian.toString().substring(beginAssignedCustodian, endAssignedCustodian);
			if(debug&gt;=2) logger.error(&apos;assignedCustodian= &apos;+assignedCustodian);
			if(assignedCustodian.toString().indexOf(&apos;representedCustodianOrganization&apos;)&gt;-1) {
				var beginRepresentedCustodianOrganization=	assignedCustodian.toString().indexOf(&apos;&lt;representedCustodianOrganization&gt;&apos;);
				var endRepresentedCustodianOrganization=	assignedCustodian.toString().indexOf(&apos;&lt;/representedCustodianOrganization&gt;&apos;);
				var representedCustodianOrganization= assignedCustodian.toString().substring(beginRepresentedCustodianOrganization, endRepresentedCustodianOrganization);
				if(debug&gt;=2) logger.error(&apos;begin= &apos;+beginRepresentedCustodianOrganization+&apos; end= &apos;+endRepresentedCustodianOrganization+&apos; representedOrganization= &apos;+representedCustodianOrganization);
				if(representedCustodianOrganization.toString().indexOf(&apos;telecom&apos;)&gt;-1) {
					var beginTelecom=		representedCustodianOrganization.toString().indexOf(&apos;&lt;telecom&apos;);
					var endTelecom= 		representedCustodianOrganization.toString().indexOf(&apos;&lt;addr&apos;);
					var telecom= 			representedCustodianOrganization.toString().substring(beginTelecom, endTelecom);
					if(debug&gt;=2) logger.error(&apos;begin= &apos;+beginTelecom+&apos; end= &apos;+endTelecom+&apos; telecom= &apos;+telecom);
					var objObservation= 	new Object();
					objObservation.id= 		i;
					beginTelecomValue= 		telecom.toString().indexOf(&apos;value=&apos;);
					endTelecomValue=   		telecom.toString().indexOf(&apos; use=&apos;);
					objObservation.value=	telecom.toString().substring(beginTelecomValue+6, endTelecomValue).replace(/&quot;/g,&apos;&apos;)
					beginTelecomUse=   		telecom.toString().indexOf(&apos;use=&apos;);
					objObservation.use= 	telecom.toString().substring(beginTelecomUse+4, beginTelecomUse+7).replace(/&quot;/g,&apos;&apos;);
					arrObservation.push(objObservation);
					var newTelecom= &apos;&lt;telecom value=&quot;&apos;+objObservation.value+&apos;&quot; use=&quot;&apos;+objObservation.use+&apos;&quot;/&gt;&apos;;
					var newRepresentedCustodianOrganization= representedCustodianOrganization.replace(telecom, newTelecom);
					if(debug&gt;=1) channelMap.put(tDescription,&apos;old= &apos;+telecom+&apos; new= &apos;+newTelecom);
					if(debug&gt;=2) logger.error(tDescription+&apos; old= &apos;+telecom+&apos; new= &apos;+newTelecom);
				} // end if
			} // end if 
			var newAssignedCustodian= assignedCustodian.replace(representedCustodianOrganization,newRepresentedCustodianOrganization);
		} // end if 
		var newCustodian=	custodian.replace(assignedCustodian,newAssignedCustodian);
		var newXmlMsg=    	message.replace(custodian,newCustodian);
	}// end if 

	if(debug&gt;=2) logger.error(&apos;new msg Section= &apos;+newXmlMsg);
	return newXmlMsg;			// return section
} // end function</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.1">
      <id>ccc6ffcd-366c-445a-8cc6-4a087b9611c3</id>
      <name>select_table</name>
      <revision>2</revision>
      <lastModified>
        <time>1527381331549</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>CHANNEL_BATCH</contextType>
          <contextType>CHANNEL_PREPROCESSOR</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>CHANNEL_UNDEPLOY</contextType>
          <contextType>CHANNEL_DEPLOY</contextType>
          <contextType>GLOBAL_POSTPROCESSOR</contextType>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>CHANNEL_POSTPROCESSOR</contextType>
          <contextType>CHANNEL_ATTACHMENT</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	select_table(tableName, columnArray, debug, select_log) uses getMySqlConn() function.
*/
function select_table(tableName, columnArray, debug, select_log) {

	if(typeof(debug)== &apos;undefined&apos;) 		var debug= 0;
	if(typeof(select_log)== &apos;undefined&apos;) 	var select_log= &apos;&apos;;
	var select= &quot;SELECT * FROM &quot;+tableName+ &quot; WHERE &quot;;
	var i= 1;
	for each(column in columnArray) {
		if(i&lt;columnArray.length)
			select+= column.split(&quot;:&quot;)[0].toString() + &quot;= &apos;&quot; + column.split(&quot;:&quot;)[1].toString() + &quot;&apos; AND &quot;;
		else
			select+= column.split(&quot;:&quot;)[0].toString() + &quot;= &apos;&quot; + column.split(&quot;:&quot;)[1].toString() + &quot;&apos;;&quot;;
		i++;
	} // end for each
	var select= String(select);
	if(debug&gt;=1) channelMap.put(&apos;select_&apos;+tableName,select);
	try {
		var dbConn= getMySqlConn();
		// dbConn = DatabaseConnectionFactory.createDatabaseConnection($(&apos;mysqlDriverString&apos;),$(&apos;mysqlUrlLocalHostString&apos;),$(&apos;mysqlUser&apos;),$(&apos;mysqlPassword&apos;));
		// var result = dbConn.executeUpdate(update);
		var result= dbConn.executeCachedQuery(select);
		if (result != null) {
			if(result.size()&gt;0) {
				select_log+= &apos; Found record for exam_source.&apos;;
				channelMap.put(&apos;action&apos;,&apos;FILTER FOUND&apos;);
				if(debug&gt;=1) channelMap.put(&apos;select_log_&apos;+tableName,select_log);
				if(debug&gt;=2) logger.error(&apos;[Select &apos;+tableName+&apos;]: &apos;+select_log);
				// return true;
			} else {
				select_log+= &apos; Failed to find 0 records for exam source.&apos;;
				if(debug&gt;=1) channelMap.put(&apos;select_log_&apos;+tableName,select_log);
				if(debug&gt;=2) logger.error(&apos;[Select &apos;+tableName+&apos;]: &apos;+select_log);
			} // end if 
		} else {
			select_log+= &apos; Failed to find 0 records for exam source.&apos;;
			if(debug&gt;=1) channelMap.put(&apos;select_log_&apos;+tableName,select_log);
			if(debug&gt;=2) logger.error(&apos;[Select &apos;+tableName+&apos;]: &apos;+select_log);
			// return false;
		} // end if	
		dbConn.close();
	} catch(err){
		logger.error(err);
	} finally {	
		if (dbConn) { 
			dbConn.close();
		}
	} // end try
	channelMap.put(&apos;select_log&apos;,select_log);
	return select_log;
} // end function</code>
      </properties>
    </codeTemplate>
  </codeTemplates>
</codeTemplateLibrary>